1. Two-Pointers:
    1. Find a pair with sum=k, or equal. in  sorted Array
    2. Find a triplet with sum k in sorted Array
    3. LinkedList --> loop detection, lastKthNode, fastPtr,slowPtr
    4. Merge 2 sortedLinkedList
    5. Move zeroes at end
    6. Dutch flag alogrithm (sort an array of 0,1,2)
    7. Move zeroes at start.
    8. sort an array of 0/1

2. SlidingWindow: using HashMap (sum-k)
    1. Make the biggest number by shifting k elements.
    2. Maximum sum subarray of size ‘K’ (easy)
    3. Longest substring with ‘K’ distinct characters (medium)
    4. Longest Substring with equal number of 0/1.
    5. String anagrams (hard)
    6. FindAllSubarraySum (hard) 0(n)

3. BinarySearch :
    1. sortedArray : missing number in duplicates of 2n+1, first & last occurence, ceil & floor
    2. nonSortedArray : peak element, search in rotatedSortedArray, Bitonic Array

4. MergeIntervals/ Scheduling
    1. Basic 2 condition for collision : (start1>=start2 && start1<=end2) || (start2>=start1 && start2<=end1)
    2. numberOfStations/MeetingRoom : given (start,end) of trains find min stations needed to accomodate / Find meeting rooms needed
    3. Find common Calendar Availability : given times of 2 people (start,end) find available time slot for meeting.

5. Sorting:
    1. QuickSort : In an array of nuts and bolts having same number, sort it , you can compare nuts with nuts and bolts with bolts.
    2. MergeSort
    3. CountingSort

6. PrefetchSum :
    1. Add number to range (+50 to 1->3 index) : add to front and subtract from end+1; perform prefetch later on.

7. Bitwise:
    1. find missing element in non-sorted duplicated array of 2n+1; -->XOR(^)
    2. find 2 missing element in non-sorted duplicated array of 2n+2;
    3. check odd/even using binary (& | )

8. Heap (PriorityQueue)
    1. Find median in running stream
    2. Find kth Max in running stream
    3. Find Median of 2 sorted Array (same size)
    4. Find median of 2 sorted array (differenc size)
    5. Find Min Meeting rooms needed to accomodate n meetings(optimised is using merge intervals);
    6. Sort a K sorted Array
    7. Rearrange String such that no 2 same characters are adjacent. "aabbacc" --> abcabca
    8. MinRemovalUnique : min removal of each char such that the count of each char is unique.
    9. String without AAABBB

9. String
    Search
        1. KnutthMorris prat : skip the elements already traversed.
        2. RainKarp : hash
        3. Tries : prefix based searching.
    2. LexicographicallyStringJustGreaterThanCurrent ex dhck-> dhkc


10. Maths:
    1. Find palindrome of a number
    2. Find the smallest missing sum which cant be computed from the elements sum(used in any manner)
           1,2,3,6  --> 13
           1,2,5,6 --> 4
           2,5,6 --> 1
           Hint: idea is to keep computing the prefix sum and check whether prefixSum+1 < nextElement if(yes) then prefixSum+1 is the ans
    3. HCF/LCM/10.3 --> 3.3333..  --> 3.(3) --> use remainder than string searching, deciamls repeat if remainder comes same.

11. Recursion :
    1. Find HCF/LCM
    2. Find power of a number
    3. Water jug fill
    4. MasterTheorem for time complexity

12. Subsets:
    The total number of subsets of a given set of size n is equal to 2^n.
    The total number of subarray = n*(n+1)/2 i.e. time complexity n^2

13. Dp: (Memoization TOP-DOWN) , Tabluation : bottom-up
    1. fibonacciNumbers: MinJumpsToReachEnd, Staircase, HouseTheif
    2. BoundedKnapsack : Knapsack 0/1 : Limited quantity
    3. Unbounded Knapsack
    4. LongestCommonSubstring
    5. LongestCommonSubsequence

14. BFS:
    1. Rotten oranges.

15. GraphTheory:
    1. BFS
    2. DFS
    3. MST: Prim's kruskal
    4. ShortestDistance : BFS,  Dijkstra, bellmanFord , Topological sort
    5. TopologicalSort
    6. NegativeCycle : Bellman Ford
