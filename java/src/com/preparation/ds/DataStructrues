1. Arrays:
    1. Kandane Algorithm : LongestContinousSum
    2. Bayer Moore Alogrithm : MajorityElement
           2. Find n/3 majority elemnt using above(2 majElement using Bayer moore)
    3. Sum-k / HashMap(sum-k) : LongestConsecutive problems
    4. Using index as count : CountingSort/ first missing +ve integer
    5. Prefetch sum :
    6. +50(start)/-50(end) : using prefetch to perform operations on a range of indexes.
    7. Converting Char to Int : char-'a';
    8. converting int to char : i-'0'
    9. Spiral traverse : 4 for loops and with recursion

2. LinkedList:
    1. reverse
    2. find the mid in a single traversal
    3. find last kth element.
    4. Find loop
    5. Total number of elements in a loop.
    6. Break the loop (find total number of elements in a loop, 2 pointer, f->start, s-> start+noOfNodesInALoop,
        where they meet, break it)
    7. Merge 2 sorted list
    8. isPalindrome()
    9. Sum2LinkedList
    10. Add 1 to Linkedlist
    11. Rearrange a LinkedList as f1,mid,f2,mid+1,f3,mid+3
    12. Clone a linkedlist with random pointer
    13. remove the current node(where you are stnding) in the linkedList. Head not given.
    14. Flatten a linkedList having childNode.
    15. Reverse in size k --> use start,end of a window.

3. Stack: FIFO
    1. stock span problem
    2. equal brackets.

4. Queue : LIFO : BFS

5. ArrayList --> built with arrays, Set --> built on top of HashMap.
6. TreeMap : sorted by keys

7. Trees:
    1. Traversal : (DFS)pre, post, in, levelOrder(queue/BFS)
    2. size
    3. maxPathSum
    4. minPathSum
    5. FindAncestors of a node.
    6. find all nodes at distance k from node --> find ancestors and use it.
    7. find max subTree : Diameter : Or similar question --> Find the maximum path sum between two leaves of a binary tree
    8. top view, left view, right view
    9. mirror of a tree

    BST : insertion, deletion, search
    Heap
    AVL , Red Black tree
    Tries

8. Graph (already provided)